-- DO NOT EDIT THIS FILE
-- This file is automatically overwritten by the installer
-- This file contains reusable functions for CoolingControl

-- Create a table to hold the module's functions/variables
local M = {}  

-- Global variables for EMA
M.last_sensor_values = {} 
  
--- Applies an Exponential Moving Average (EMA) to a sensor value.
---
--- This function calculates a smoothed value for a given sensor reading
--- using the EMA formula. If the sensor has no previous value stored,
--- the current value is used as the initial value.
---
--- @param sensor_alias string: The alias for the sensor.
--- @param value number: The current sensor reading to be smoothed.
--- @param alpha number|nil: The smoothing factor (0 < alpha <= 1). Defaults to 0.4 if not provided.
--- @return number: The smoothed sensor value after applying EMA.
function M.apply_ema(sensor_alias, value, alpha)
    alpha = alpha or 0.4
    local last_value = M.last_sensor_values[sensor_alias]
    if last_value == nil then
        M.last_sensor_values[sensor_alias] = value
        return value
    end

    local ema = alpha * value + (1 - alpha) * last_value
    M.last_sensor_values[sensor_alias] = ema
    return ema
end

-- Global variables for hysteresis state
M.last_trigger_sensor_values = {} -- Last sensor values that triggered a control change
M.breach_counters = {} -- Number of continuous threshold breaches
M.last_control_values = {} -- Last applied control values

-- Helper function to apply hysteresis
--- Applies hysteresis logic to a control to prevent rapid switching.
---
--- This function adjusts the control value based on the sensor value and hysteresis threshold,
--- ensuring that the control avoids frequent toggling.
---
--- @param control_alias string: The alias of the control being adjusted.
--- @param control_value number: The proposed value of the control.
--- @param sensor_value number: The current value of the sensor being monitored.
--- @param min_value number: Min sensor value where hysteresis is ignored.
--- @param max_value number: Max sensor value where hysteresis is ignored.
--- @param response_time number: The time (in update ticks) for the control to respond to changes.
--- @param hysteresis_threshold number: The threshold sensor value for hysteresis to prevent rapid switching.
--- @return number: The adjusted control value after applying hysteresis logic.
function M.apply_hysteresis(control_alias, control_value, sensor_value, min_value, max_value, response_time, hysteresis_threshold)
    max_value = max_value or 100
    min_value = min_value or 30 
    response_time = response_time or 4
    hysteresis_threshold = hysteresis_threshold or 2
    
    local breach_counter = M.breach_counters[control_alias] or 0

    local function handle_new_control()
        if breach_counter == response_time then
            -- Response time reached, apply control value
            M.last_trigger_sensor_values[control_alias] = sensor_value
            M.last_control_values[control_alias] = control_value
            M.breach_counters[control_alias] = 0
            return control_value
        else
            -- Response time not reached, control value not applied
            M.breach_counters[control_alias] = breach_counter + 1
            return M.last_control_values[control_alias]
        end
    end

    if M.last_trigger_sensor_values[control_alias] == nil then
        -- Init
        M.last_trigger_sensor_values[control_alias] = sensor_value
        M.last_control_values[control_alias] = control_value
        M.breach_counters[control_alias] = 0
        return control_value
    end

    if sensor_value <= min_value then
        -- log_debug(string.format("<=%f control_alias: %s, sensor_value: %f, last_sensor_value: %f", min_value, control_alias, sensor_value, M.last_trigger_sensor_values[control_alias]))
        return handle_new_control()
    end
    if sensor_value >= max_value then
        -- log_debug(string.format(">=%f control_alias: %s, sensor_value: %f, last_sensor_value: %f",  max_value, control_alias, sensor_value, M.last_trigger_sensor_values[control_alias]))
        return handle_new_control()    
    end

    local last_sensor_value = M.last_trigger_sensor_values[control_alias]

    if math.abs(last_sensor_value - sensor_value) > hysteresis_threshold then
        -- log_debug(string.format("Ds>%f control_alias: %s, sensor_value: %f, last_sensor_value: %f",  hysteresis_threshold, control_alias, sensor_value, last_sensor_value))
        return handle_new_control()
    else
        -- log_debug(string.format("Ds<%f control_alias: %s, sensor_value: %f, last_sensor_value: %f",  hysteresis_threshold, control_alias, sensor_value, last_sensor_value))
        M.breach_counters[control_alias] = 0
        return M.last_control_values[control_alias]
    end
end

-- Calculate control value based on curve (step function)
--- Applies a step curve to a given sensor value and returns the corresponding control value.
--- The curve must be sorted in ascending order by `sensor_value`. If the curve is not sorted, 
--- an error is raised.
---
--- @param sensor_value number: The sensor value to evaluate.
--- @param curve table: A table of points defining the step curve. Each point is a table with 
--- `sensor_value` (number) and `control_value` (number) fields.
--- @return number: The control value corresponding to the given sensor value.
function M.apply_step_curve(sensor_value, curve)
    if #curve < 2 then
        error("Curve must contain at least two points")
    end

    if sensor_value <= curve[1].sensor_value then return curve[1].control_value end
    if sensor_value >= curve[#curve].sensor_value then return curve[#curve].control_value end

    for i = 1, #curve - 1 do
        local low = curve[i]
        local high = curve[i + 1]
        if sensor_value >= low.sensor_value and sensor_value < high.sensor_value then
            return low.control_value 
        end
    end

    error("Curve is not sorted by sensor_value")
end

-- Calculate control value based on curve (linear interpolation)
--- Applies a linear interpolation based on a given sensor value and a curve.
--- The function assumes hat the curve is sorted in ascending order by `sensor_value`.
---
--- @param sensor_value number: The input sensor value to evaluate.
--- @param curve table: A sorted table of points defining the curve. Each point
--- should be a table with `sensor_value` (number) and `control_value` (number).
--- @return number The interpolated control value corresponding to the input sensor value.
function M.apply_linear_curve(sensor_value, curve)
    if #curve < 2 then
        error("Curve must contain at least two points")
    end

    if sensor_value <= curve[1].sensor_value then return curve[1].control_value end
    if sensor_value >= curve[#curve].sensor_value then return curve[#curve].control_value end

    for i = 1, #curve - 1 do
        local low = curve[i]
        local high = curve[i + 1]
        if sensor_value >= low.sensor_value and sensor_value < high.sensor_value then
            local t_ratio = (sensor_value - low.sensor_value) / (high.sensor_value - low.sensor_value)
            return low.control_value + t_ratio * (high.control_value - low.control_value)
        end
    end

    error("Curve is not sorted by sensor_value")
end

--- Controls AIO pump speed based on the CPU power consumption.
---
--- It uses linear interpolation between the minimum and maximum RPM values
--- for the pump when the CPU power is between the idle and
--- maximum power thresholds. Limits for pump speed should be set
--- according to noise preferences and AIO size.
---
--- @param cpu_temp number: The current CPU temperature in °C.
--- @param cpu_power number: The current CPU power consumption.
--- @param idle_cpu_power number: The CPU power consumption at idle state.
--- @param max_cpu_power number: The maximum CPU power consumption.
--- @param min_pump_rpm number: The minimum pump speed in RPM.
--- @param max_pump_rpm number: The maximum pump speed in RPM.
--- @return number: The calculated pump speed in RPM.
function M.aio_pump_control(cpu_temp, cpu_power, idle_cpu_power, max_cpu_power, min_pump_rpm, max_pump_rpm)

    -- Safety override: If CPU temperature is too high, set max pump speed
    if cpu_temp > 95 then
        return max_pump_rpm
    end

    local pump_rpm
  
    if cpu_power <= idle_cpu_power then
        pump_rpm = min_pump_rpm
    elseif cpu_power >= max_cpu_power then
        pump_rpm = max_pump_rpm
    else
        local ratio = (cpu_power - idle_cpu_power) / (max_cpu_power - idle_cpu_power)
        pump_rpm = min_pump_rpm + (max_pump_rpm - min_pump_rpm) * ratio
    end  

    pump_rpm = math.max(min_pump_rpm, math.min(max_pump_rpm, pump_rpm))

    return pump_rpm
end

-- Global variables for PID control
M.integral = {}

--- Controls AIO fan speed based on the coolant temperature.
---
--- Calculates and returns a fan speed (RPM) based on the difference
--- between the current coolant temperature and a target temperature.
---
--- @param coolant_alias string: Identifier for the coolant sensor
--- @param coolant_temp number: Current coolant temperature
--- @param target_temp number: Desired coolant temperature setpoint
--- @param min_fan_rpm number: The minimum fan speed in RPM.
--- @param max_fan_rpm number: The maximum fan speed in RPM.
--- @param dt number?: Time step in seconds (optional, defaults to 1)
--- @return number: The calculated fan speed in RPM.
function M.aio_fan_pid_control(coolant_alias, coolant_temp, target_temp, min_fan_rpm, max_fan_rpm, dt)
    dt = dt or 1

    local Kp, Ki = 90, 15
    local max_integral = (max_fan_rpm - min_fan_rpm) / (Ki * 2)

    -- Safety override: If coolant temperature is too high, set max fan speed
    if coolant_temp > 60 then
        M.integral[coolant_alias] = max_integral
        return max_fan_rpm
    end

    local error = coolant_temp - target_temp

    local integral = M.integral[coolant_alias] or -max_integral
    integral = integral + error * dt

    -- Clamp integral to prevent windup
    if integral > max_integral then
        integral = max_integral
    elseif integral < -max_integral then
        integral = -max_integral
    end

    local fan_rpm = (max_fan_rpm + min_fan_rpm) / 2 + Kp * error + Ki * integral

    M.integral[coolant_alias] = integral

    log_debug(string.format("Temp: %.1f, Error: %.1f, Integral: %.1f, Fan: %.1f", coolant_temp, error, integral, fan_rpm))

    return math.min(max_fan_rpm, math.max(min_fan_rpm, fan_rpm))
end

--- Controls fan speed based on the CPU power consumption.
---
--- It uses linear interpolation between the minimum and maximum RPM values
--- for the fan when the CPU power is between the idle and
--- maximum power thresholds. Limits for fan speed should be set
--- according to noise preferences and AIO size.
---
--- @param cpu_temp number: The current CPU temperature in °C.
--- @param cpu_power number: The current CPU power consumption.
--- @param idle_cpu_power number: The CPU power consumption at idle state.
--- @param max_cpu_power number: The maximum CPU power consumption.
--- @param min_fan_rpm number: The minimum fan speed in RPM.
--- @param max_fan_rpm number: The maximum fan speed in RPM.
--- @param ambient_temp number|nil: The ambient temperature in °C. Defaults to 24°C if not provided.
--- @return number: The calculated fan speed in RPM.
function M.aio_fan_control(cpu_temp, cpu_power, idle_cpu_power, max_cpu_power, min_fan_rpm, max_fan_rpm, ambient_temp)
    ambient_temp = ambient_temp or 24 -- Default ambient temperature if not provided

    -- Safety override: If CPU temperature is too high, set max fan speed
    if cpu_temp > 95 then
        return max_fan_rpm
    end

    -- Temperature-based adjustment
    local temp_modifier = 1.0
    if cpu_temp >= 80 then
        temp_modifier = temp_modifier * 1.1  -- Increase by 10% if temp >= 80°C
    elseif cpu_temp <= 50 then
        temp_modifier = temp_modifier * 0.9  -- Decrease by 10% if temp <= 50°C
    end

    -- Ambient temperature adjustment
    local ambient_modifier = 1.0
    if ambient_temp > 24 then
        ambient_modifier = 1 + (ambient_temp - 24) * 0.02 -- Increase by 2% per °C above 24°C
    elseif ambient_temp < 24 then
        ambient_modifier = 1 - (24 - ambient_temp) * 0.01 -- Decrease by 1% per °C below 24°C
    end
   
    local fan_rpm
  
    if cpu_power <= idle_cpu_power then
        fan_rpm = min_fan_rpm
    elseif cpu_power >= max_cpu_power then
        fan_rpm = max_fan_rpm
    else
        local ratio = (cpu_power - idle_cpu_power) / (max_cpu_power - idle_cpu_power)
        fan_rpm = min_fan_rpm + (max_fan_rpm - min_fan_rpm) * ratio
    end  

    local final_fan_rpm = math.max(min_fan_rpm, math.min(max_fan_rpm, fan_rpm * temp_modifier * ambient_modifier))

    return final_fan_rpm
end

--- Resets the state variables used for cooling control.
--- This function is called when resuming the cooling control system.
function M.on_resume()
    M.last_sensor_values = {} 
    M.last_trigger_sensor_values = {} 
    M.breach_counters = {} 
    M.last_control_values = {} 
end

return M