-- DO NOT EDIT THIS FILE
-- This file is automatically overwritten by the installer
-- This file contains reusable functions for CoolingControl

-- Create a table to hold the module's functions/variables
local M = {}  

-- Global variables for EMA
M.last_sensor_values = {} 
  
--- Applies an Exponential Moving Average (EMA) to a sensor value.
---
--- This function calculates a smoothed value for a given sensor reading
--- using the EMA formula. If the sensor has no previous value stored,
--- the current value is used as the initial value.
---
--- @param sensor_alias string: The alias for the sensor.
--- @param value number: The current sensor reading to be smoothed.
--- @param alpha number|nil: The smoothing factor (0 < alpha <= 1). Defaults to 0.4 if not provided.
--- @return number: The smoothed sensor value after applying EMA.
function M.apply_ema(sensor_alias, value, alpha)
    alpha = alpha or 0.4
    local last_value = M.last_sensor_values[sensor_alias]
    if last_value == nil then
        M.last_sensor_values[sensor_alias] = value
        return value
    end

    local ema = alpha * value + (1 - alpha) * last_value
    M.last_sensor_values[sensor_alias] = ema
    return ema
end

-- Global variables for hysteresis state
M.last_trigger_sensor_values = {} -- Last sensor values that triggered a control change
M.breach_counters = {} -- Number of continuous threshold breaches
M.last_control_values = {} -- Last applied control values

-- Helper function to apply hysteresis
--- Applies hysteresis logic to a control to prevent rapid switching.
---
--- This function adjusts the control value based on the sensor value and hysteresis threshold,
--- ensuring that the control avoids frequent toggling.
---
--- @param control_alias string: The alias of the control being adjusted.
--- @param control_value number: The proposed value of the control.
--- @param sensor_value number: The current value of the sensor being monitored.
--- @param min_value number: Min sensor value where hysteresis is ignored.
--- @param max_value number: Max sensor value where hysteresis is ignored.
--- @param response_time number: The time (in update ticks) for the control to respond to changes.
--- @param hysteresis_threshold number: The threshold sensor value for hysteresis to prevent rapid switching.
--- @return number: The adjusted control value after applying hysteresis logic.
function M.apply_hysteresis(control_alias, control_value, sensor_value, min_value, max_value, response_time, hysteresis_threshold)
    max_value = max_value or 100
    min_value = min_value or 30 
    response_time = response_time or 4
    hysteresis_threshold = hysteresis_threshold or 2
    
    local breach_counter = M.breach_counters[control_alias] or 0

    local function handle_new_control()
        if breach_counter == response_time then
            -- Response time reached, apply control value
            M.last_trigger_sensor_values[control_alias] = sensor_value
            M.last_control_values[control_alias] = control_value
            M.breach_counters[control_alias] = 0
            return control_value
        else
            -- Response time not reached, control value not applied
            M.breach_counters[control_alias] = breach_counter + 1
            return M.last_control_values[control_alias]
        end
    end

    if M.last_trigger_sensor_values[control_alias] == nil then
        -- Init
        M.last_trigger_sensor_values[control_alias] = sensor_value
        M.last_control_values[control_alias] = control_value
        M.breach_counters[control_alias] = 0
        return control_value
    end

    if min_value and sensor_value <= min_value then
        -- log_debug(string.format("<=%f control_alias: %s, sensor_value: %f, last_sensor_value: %f", min_value, control_alias, sensor_value, M.last_trigger_sensor_values[control_alias]))
        return handle_new_control()
    end
    if max_value and sensor_value >= max_value then
        -- log_debug(string.format(">=%f control_alias: %s, sensor_value: %f, last_sensor_value: %f",  max_value, control_alias, sensor_value, M.last_trigger_sensor_values[control_alias]))
        return handle_new_control()    
    end

    local last_sensor_value = M.last_trigger_sensor_values[control_alias]

    if math.abs(last_sensor_value - sensor_value) > hysteresis_threshold then
        -- log_debug(string.format("Ds>%f control_alias: %s, sensor_value: %f, last_sensor_value: %f",  hysteresis_threshold, control_alias, sensor_value, last_sensor_value))
        return handle_new_control()
    else
        -- log_debug(string.format("Ds<%f control_alias: %s, sensor_value: %f, last_sensor_value: %f",  hysteresis_threshold, control_alias, sensor_value, last_sensor_value))
        M.breach_counters[control_alias] = 0
        return M.last_control_values[control_alias]
    end
end

-- Calculate control value based on curve (step function)
--- Applies a step curve to a given sensor value and returns the corresponding control value.
--- The curve must be sorted in ascending order by `sensor_value`. If the curve is not sorted, 
--- an error is raised.
---
--- @param sensor_value number: The sensor value to evaluate.
--- @param curve table: A table of points defining the step curve. Each point is a table with 
--- `sensor_value` (number) and `control_value` (number) fields.
--- @return number: The control value corresponding to the given sensor value.
function M.apply_step_curve(sensor_value, curve)
    if #curve < 2 then
        error("Curve must contain at least two points")
    end

    if sensor_value <= curve[1].sensor_value then return curve[1].control_value end
    if sensor_value >= curve[#curve].sensor_value then return curve[#curve].control_value end

    for i = 1, #curve - 1 do
        local low = curve[i]
        local high = curve[i + 1]
        if sensor_value >= low.sensor_value and sensor_value < high.sensor_value then
            return low.control_value 
        end
    end

    error("Curve is not sorted by sensor_value")
end

-- Calculate control value based on curve (linear interpolation)
--- Applies a linear interpolation based on a given sensor value and a curve.
--- The function assumes hat the curve is sorted in ascending order by `sensor_value`.
---
--- @param sensor_value number: The input sensor value to evaluate.
--- @param curve table: A sorted table of points defining the curve. Each point
--- should be a table with `sensor_value` (number) and `control_value` (number).
--- @return number The interpolated control value corresponding to the input sensor value.
function M.apply_linear_curve(sensor_value, curve)
    if #curve < 2 then
        error("Curve must contain at least two points")
    end

    if sensor_value <= curve[1].sensor_value then return curve[1].control_value end
    if sensor_value >= curve[#curve].sensor_value then return curve[#curve].control_value end

    for i = 1, #curve - 1 do
        local low = curve[i]
        local high = curve[i + 1]
        if sensor_value >= low.sensor_value and sensor_value < high.sensor_value then
            local t_ratio = (sensor_value - low.sensor_value) / (high.sensor_value - low.sensor_value)
            return low.control_value + t_ratio * (high.control_value - low.control_value)
        end
    end

    error("Curve is not sorted by sensor_value")
end


--- Controls the pump and fan speeds based on the CPU power consumption.
--- 
--- This function calculates the appropriate pump and fan speeds to maintain
--- optimal cooling performance based on the current CPU power consumption.
--- It uses linear interpolation between the minimum and maximum RPM values
--- for both the pump and fan when the CPU power is between the idle and
--- maximum power thresholds.
---
--- @param cpu_power number: The current CPU power consumption.
--- @param idle_cpu_power number: The CPU power consumption at idle state.
--- @param max_cpu_power number: The maximum CPU power consumption.
--- @param min_pump_rpm number: The minimum pump speed in RPM.
--- @param max_pump_rpm number: The maximum pump speed in RPM.
--- @param min_fan_rpm number: The minimum fan speed in RPM.
--- @param max_fan_rpm number: The maximum fan speed in RPM.
--- @return table result A table containing the calculated pump and fan speeds:
---   - pump_rpm (number): The calculated pump speed in RPM.
---   - fan_rpm (number): The calculated fan speed in RPM.
function M.aio_control(cpu_power, idle_cpu_power, max_cpu_power, min_pump_rpm, max_pump_rpm, min_fan_rpm, max_fan_rpm)
    local result = {}

    local pump_speed
    local fan_speed
  
    if cpu_power <= idle_cpu_power then
        pump_speed = min_pump_rpm
        fan_speed = min_fan_rpm
    elseif cpu_power >= max_cpu_power then
        pump_speed = max_pump_rpm
        fan_speed = max_fan_rpm
    else
        pump_speed = min_pump_rpm + (max_pump_rpm - min_pump_rpm) * (cpu_power - idle_cpu_power) / (max_cpu_power - idle_cpu_power) 
        fan_speed = min_fan_rpm + (max_fan_rpm - min_fan_rpm) * (cpu_power - idle_cpu_power) / (max_cpu_power - idle_cpu_power) 
    end  

    return {
        pump_rpm = pump_speed,
        fan_rpm = fan_speed
    }
end

--- Resets the state variables used for cooling control.
--- This function is called when resuming the cooling control system.
function M.on_resume()
    M.last_sensor_values = {} 
    M.last_trigger_sensor_values = {} 
    M.breach_counters = {} 
    M.last_control_values = {} 
end

return M